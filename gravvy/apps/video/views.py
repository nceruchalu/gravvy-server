import os
import subprocess
from tempfile import NamedTemporaryFile

from django.shortcuts import get_object_or_404, render_to_response
from django.http import Http404, HttpResponseRedirect
from django.core.exceptions import ValidationError
from django.contrib.contenttypes.models import ContentType
from django.db.models import F, Q
from django.utils import timezone
from django.template import RequestContext
from django.core.urlresolvers import reverse
from django.core.files.uploadhandler import TemporaryFileUploadHandler
from django.views.decorators.csrf import csrf_exempt, csrf_protect
from django.core.files.base import File
from django.core.files.images import ImageFile
from django.conf import settings

from rest_framework import (
    generics, status, permissions, parsers, renderers, exceptions)
from rest_framework.response import Response

from gravvy.apps.video.models import Video, Clip, VideoUsers
from gravvy.apps.video.serializers import (
    VideoSerializer, VideoCreationSerializer, VideoUserSerializer,
    VideoUsersCreationSerializer, ClipSerializer)
from gravvy.apps.video.permissions import (
    IsOwnerOrReadOnly, IsAssociatedUser, IsAssociatedUserOrReadOnly,
    IsOwnerOrUserDetailOwner, IsVideoOwnerOrClipOwnerOrReadOnly)
from gravvy.apps.video.forms import UploadClipForm

from gravvy.apps.account.models import User
from gravvy.apps.account.serializers import UserPublicSerializer

from gravvy.apps.activity import activity
from gravvy.apps.activity.models import Activity

# Create your views here.

# ------------------------------------------------------------------------------
# Activity Helper Function
# ------------------------------------------------------------------------------
def activity_send(user, verb=None, object=None, target=None):
    """
    wrapper method to activity.send() which updates VideoUser objects with
    corresponding stats.
    """
    if target is None:
        activity.send(user, verb=verb, object=object)
        video = object
    else:
        activity.send(user, verb=verb, object=object, target=target)
        if isinstance(target, Video):
            video = target
        else:
            video = object
    
    if isinstance(video, Video):
        # get video's users
        video_users = VideoUsers.objects.filter(video_id=video.id)
        
        # update their stats and send push notifications
        if verb == 'like':
            # get video's other users
            video_users = video_users.exclude(user_id = user.id)
            video_users.update(new_likes_count = F('new_likes_count') + 1)
            
        elif verb == 'add':
            video_users.update(new_clips_count = F('new_clips_count') + 1)
        
        elif verb == 'invite':
            pass
    
    
# ------------------------------------------------------------------------------
# VIDEO LIST
# ------------------------------------------------------------------------------
class VideoList(generics.CreateAPIView):
    """
    Create a new video.
    
    ## Reading
    You can't read using this endpoint. This is really a privacy decision
    
    
    ## Publishing
    ### Permissions
    * Only authenticated users can create using this endpoint.
    
    ### Fields
    Parameter      | Description                         | Type
    -------------- | ----------------------------------- | ----------
    `lead_clip`    | video's first clip. **Required**    | _Clip object_
    `users`        | list of video's users. **Required** | _User number objects_
    `title`        | video's title.                      | _string_
    `description`  | video's description                 | _string_
    
    ##
    The **`Clip object`** has following parameters
    
    Parameter  | Description                                        | Type
    ---------- | -------------------------------------------------- | --------- 
    `mp4`      | The video file of the clip. **Required**           | _file_
    `photo`    | An image frame captured from the mp4. **Required** | _file_
    `duration` | Length of the video clip, in seconds. **Required** | _integer_
    
    Submitting files requires uploading viles via **multipart/form-data** and 
    using appropriate paramters.
        
    ### Response
    If create is successful, an enhanced video object, with the **lead_clip** 
    and **users** objects included, otherwise an error message. 
    The video object has the following fields:
    
    Name              | Description                             | Type
    ----------------- | --------------------------------------- | ---------- 
    `url`             | URL of new video object                 | _string_
    `hash_key`        | autogenerated unique identifier         | _string_
    `owner`           | video creator                           | _User object_
    `title`           | video's title                           | _string_
    `photo_thumbnail` | cached copy of leading clip's photo thumbnail | _string_
    `photo_small_thumbnail` | cached copy of a smaller thumbnail      | _string_
    `lead_clip`       | first video clip in the stream          | _Clip object_
    `users`           | a list of video's users.         | _User number objects_
    `liked`           | has user liked video?                   | _boolean_
    `likes_count`     | cached total number of likes            | _integer_
    `plays_count`     | cached total number of plays            | _integer_
    `clips_count`     | cached total number of clips            | _integer_
    `duration`        | total duration of all clips' mp4s       | _float_
    `score`           | ranking score                           | _float_
    `new_likes_count` | unseen likes count if video user        | integer
    `new_clips_count` | unseen clips count if video user        | integer
    `membership_status` | status of video user                  | integer
    `created_at`      | video's creation date/time              | _date/time_
    `updated_at`      | last modified date of video object      | _date/time_
    `clips`           | Video's clips sub-collection            | _Clip objects_
    `users_url`       | URL of video's users sub-collection     | _string_
    
    
    ## Deleting
    You can't delete using this endpoint.
    
    
    ## Updating
    You can't update using this endpoint
        
    ## Endpoints
    Name                                   | Description                       
    -------------------------------------- | ----------------------------------
    [`<hash_key>/`](hash-key/)             | Get/Update/Delete a specific video
    [`<hash_key>/like/`](hash-key/like/)   | Record a like of a specific video
    [`<hash_key>/play/`](hash-key/play/)   | Record a play of a specific video
    [`<hash_key>/clearnotifications/`](hash-key/clearnotifications/) | Clear notifications for user
    [`<hash_key>/clips/`](hash-key/clips/) | List/Create a video's clips
    [`<hash_key>/clips/<id>/`](hash-key/clips/0/) | Get/Delete a video clip
    [`<hash_key>/users/`](hash-key/users/) | List/Add to a video's associated users
    [`<hash_key>/users/<phone_number>/`](hash-key/users/+18006927753/) | Check/Add/Remove user as a video user
    [`<hash_key>/likes/`](hash-key/likes/) | List a video's likers
    
    ##
    """
    parser_classes = (parsers.JSONParser, parsers.MultiPartParser,)
    permission_classes = (permissions.IsAuthenticated,)
    queryset = Video.objects.all()
    serializer_class = VideoCreationSerializer
    

# -----------------------------------------------------------------------------
# VIDEO'S DETAILS AND ASSOCIATED ACTIONS
# -----------------------------------------------------------------------------

class VideoDetail(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update or destroy a video instance
    
    ## Reading
    ### Permissions
    * Anyone can read this endpoint.
    
    ### Fields
    Reading this endpoint returns a video object containing its summary data.
    
    Name              | Description                             | Type
    ----------------- | --------------------------------------- | ---------- 
    `url`             | URL of new video object                 | _string_
    `hash_key`        | autogenerated unique identifier         | _string_
    `owner`           | video creator                           | _User object_
    `title`           | video's title                           | _string_
    `photo_thumbnail` | cached copy of leading clip's photo thumbnail | _string_
    `photo_small_thumbnail` | cached copy of a smaller thumbnail      | _string_
    `liked`           | has user liked video?                   | _boolean_
    `likes_count`     | cached total number of likes            | _integer_
    `plays_count`     | cached total number of plays            | _integer_
    `clips_count`     | cached total number of clips            | _integer_
    `duration`        | total duration of all clips' mp4s       | _float_
    `score`           | ranking score                           | _float_
    `new_likes_count` | unseen likes count if video user        | integer
    `new_clips_count` | unseen clips count if video user        | integer
    `membership_status` | status of video user                  | integer
    `created_at`      | video's creation date/time              | _date/time_
    `updated_at`      | last modified date of video object      | _date/time_
    `clips`           | Video's clips sub-collection            | _Clip objects_
    `users_url`       | URL of video's users sub-collection     | _string_
        
    
    ## Publishing
    You can't create using this endpoint
    
    
    ## Deleting
    ### Permissions
    * Only authenticated users can delete this endpoint.
    * Only authenticated users can only delete videos they own
    
    ### Response
    If deletion is successful, HTTP 204: No Content, otherwise an error message.
    
    
    ## Updating
    ### Permissions
    * Only authenticated users can write to this endpoint.
    * Authenticated users can only update videos they own.
    
    
    ### Fields
    Parameter     | Description                    | Type
    ------------- | ------------------------------ | ----------
    `title`       | video's new title              | _string_
    `description` | video's new description        | _string_
      
    ### Response
    If update is successful, a Video object containing summary data, 
    otherwise an error message.
    
    
    ## Endpoints
    Name                    | Description                       
    ----------------------- | ----------------------------------------
    [`like/`](like/)        | Record a like of this video
    [`play/`](play/)        | Record a play of this video
    [`clearnotifications/`](clearnotifications/) | Clear notifications for user
    [`clips/`](clips/)      | List/Create video's clips
    [`clips/<id>/`](clips/0/) | Get/Delete video clip
    [`users/`](users/)      | List/Add to video's associated users
    [`users/<phone_number>/`](users/+18006927753/) | Check/Add/Remove user as a video user
    [`likes/`](likes/)      | List video's likers
               
    ##
    """
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,
                          IsOwnerOrReadOnly,)
    queryset = Video.objects.all().select_related('owner')
    serializer_class = VideoSerializer
    
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'


class VideoDetailLike(generics.GenericAPIView):
    """
    Get/Record/Delete a like on a video instance
    
    ## Reading
    ### Permissions
    * Only authenticated users can check a like using this endpoint
    
    ### Response
    If video is liked by user, HTTP 204: No Content, otherwise an 
    HTTP 404: Not Found.
    
    
    ## Publishing
    You can't create using this endpoint.
    
    
    ## Deleting
    ### Permissions
    * Only authenticated users can unlike a video using this endpoint.
    
    ### Response
    If deletion is successful, HTTP 204: No Content, otherwise an error message.
    
    
    ## Updating
    ### Permissions
    * Only authenticated users can submit a like using this endpoint.
    
    ### Response
    If update is successful, HTTP 204: No Content, otherwise an error message.
    
    """
    permission_classes = (permissions.IsAuthenticated,)
    queryset = Video.objects.all()
    serializer_class = VideoSerializer
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'
    
    def get(self, request, *args, **kwargs):
        video = self.get_object()
        already_liked = self.get_activity_queryset(
            request.user, video).exists()        
        status_code = (status.HTTP_204_NO_CONTENT if 
                       already_liked else status.HTTP_404_NOT_FOUND)
        return Response(status=status_code)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)
    
    def update(self, request, *args, **kwargs):
        video = self.get_object()
        already_liked = self.get_activity_queryset(request.user, video).exists()
        if not already_liked:
            activity_send(request.user, verb='like', object=video)
            video.refresh_likes_count()
            video.send_new_like_notification(request.user)
        return Response(status=status.HTTP_204_NO_CONTENT)

    def delete(self, request, *args, **kwargs):
        video = self.get_object()
        self.get_activity_queryset(request.user, video).delete()
        video.refresh_likes_count()
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    def get_activity_queryset(self, user, video):
        return Activity.objects.filter(
            actor=user, verb='like', object_id=video.id,
            object_content_type=ContentType.objects.get_for_model(video))


class VideoDetailPlay(generics.GenericAPIView):
    """
    Record a play on a video instance
    
    ## Reading
    You can't read using this endpoint.
    
    
    ## Publishing
    You can't create using this endpoint.
    
    
    ## Deleting
    You can't delete using this endpoint.
    
    
    ## Updating
    ### Permissions
    * Anyone can submit a play using this endpoint.
    
    ### Response
    If update is successful, an object with the updated `plays_count`, otherwise
    an error message.
    
    """
    permission_classes = (permissions.AllowAny,)
    queryset = Video.objects.all()
    serializer_class = VideoSerializer
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'
    
    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)
    
    def update(self, request, *args, **kwargs):
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}
        Video.objects.filter(**filter_kwargs).update(
            plays_count=(F('plays_count') + 1), 
            updated_at=timezone.now())
        
        video = get_object_or_404(Video, **filter_kwargs)
        
        # update user's interaction status with the video
        if request.user.is_authenticated():
            try:
                video_user = VideoUsers.objects.get(
                    user_id=request.user.id, video_id=video.id)
                if video_user.status <= VideoUsers.STATUS_INVITED:
                    video_user.status = VideoUsers.STATUS_VIEWED
                    video_user.save()
            except VideoUsers.DoesNotExist:
                pass
            
        return Response({'plays_count': video.plays_count}, 
                        status=status.HTTP_200_OK)
 

class VideoDetailClearNotifications(generics.GenericAPIView):
    """
    Clear video user's notfications on a video instance
    
    ## Reading
    You can't read using this endpoint.
    
    
    ## Publishing
    You can't create using this endpoint.
    
    
    ## Deleting
    You can't delete using this endpoint.
    
    
    ## Updating
    ### Permissions
    * Only authenticated users can update using this endpoint.
    * Only associated users of a video can update using this endpoint for a
      given video.
    
    ### Response
    If update is successful, HTTP 204: No Content, otherwise an error message.
        
    """
    # No need to explicitly specify IsAssociatedUserOrReadOnly permission class
    # as the update() method explicity checks for this
    permission_classes = (permissions.IsAuthenticated,)
    queryset = Video.objects.all()
    serializer_class = VideoSerializer
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'
    
    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)
    
    def update(self, request, *args, **kwargs):
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}
        video = get_object_or_404(Video, **filter_kwargs)
        
        try:
            video_user = VideoUsers.objects.get(
                user_id=request.user.id, video_id=video.id)
            video_user.new_likes_count = 0
            video_user.new_clips_count = 0
            if video_user.status <= VideoUsers.STATUS_INVITED:
                video_user.status = VideoUsers.STATUS_VIEWED
            video_user.save()
        except VideoUsers.DoesNotExist:
            raise Http404
        
        return Response(status=status.HTTP_204_NO_CONTENT)


# -----------------------------------------------------------------------------
# VIDEO CLIP MANAGEMENT
# -----------------------------------------------------------------------------

class VideoClipList(generics.ListCreateAPIView):
    """
    List all clips of a video and create new clips.
    
    ## Reading
    ### Permissions
    * Anyone can read this endpoint.
    
    ### Fields
    Reading this endpoint returns a list of [Clip objects](0/)
                
    
    ## Publishing
    ### Permissions
    * Only authenticated users can create using this endpoint.
    * Only associated users of a video can write to this endpoint for a given 
      video.
      
    ### Fields
    Parameter | Description                                        | Type
    --------- | -------------------------------------------------- | ---------- 
    `mp4`     | The video file of the clip. **Required**           | _file_
    `photo`   | An image frame captured from the mp4. **Required** | _file_
    
    Submitting files requires uploading viles via **multipart/form-data** and 
    using appropriate paramters.
        
    ### Response
    If create is successful, a [Clip object](0/), otherwise an error message.
    
    
    ## Deleting
    You can't delete using this endpoint.
    
    
    ## Updating
    You can't update using this endpoint
    
    
    ## Endpoints
    Name                 | Description                       
    -------------------- | ------------------------------------------------
    [`<id>/`](0/)        | Get/Delete video clip
    
    ##
    """
    parser_classes = (parsers.JSONParser, parsers.MultiPartParser,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,
                          IsAssociatedUserOrReadOnly)
    serializer_class = ClipSerializer
    
    # IsAssociatedUserOrReadOnly and get_queryset() expect lookup fields
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'
    
    def get_queryset(self):
        """
        This view should return a list of all clips for the video as 
        determined by the lookup parameters of the view.
        """
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        lookup = self.kwargs.get(lookup_url_kwarg, None)
                        
        if lookup is not None:
            # Use `select_related()` on video so that the generating the clip
            # URL used in the serializer doesn't require another db hit
            return Clip.objects.filter(
                video__hash_key=lookup).select_related('owner', 'video')
        return Clip.objects.none()
    
    def perform_create(self, serializer):
        """
        Create a new clip
        """
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        lookup = self.kwargs.get(lookup_url_kwarg, None)
                        
        if lookup is not None:
            filter_kwargs = {self.lookup_field: lookup}
            video = get_object_or_404(Video, **filter_kwargs)
            clip = serializer.save(video=video, owner=self.request.user) 
                        
            # register this new activity
            activity_send(self.request.user, verb='add', object=clip, target=video)
        else:
            raise Http404
        

class VideoClipDetail(generics.RetrieveDestroyAPIView):
    """
    Retrieve or destroy a video clip instance
    
    ## Reading
    * Anyone can read this endpoint.
    
    ### Fields
    Reading this endpoint returns a Clip endpoint.
        
    Name               | Description                             | Type
    ------------------ | --------------------------------------- | ---------- 
    `url`              | URL of clip object                      | _string_
    `id`               | ID of clip object                       | _integer_
    `owner`            | Clip uploader                           | _User object_
    `order`            | 0-indexed order of clip in video stream | _integer_
    `mp4`              | Clip's mp4 file                         | _string_
    `photo_thumbnail`  | cached copy of photo thumbnail's URL    | _string_
    `duration`         | Duration of clip's mp4 file             | _float_
    `updated_at`       | last modified date of clip object       | _date/time_
            
    
    ## Publishing
    You can't write using this endpoint
    
    
    ## Deleting
    ### Permissions
    * Only authenticated users can delete this endpoint.
    * Users can only delete clips they own/uploaded.
    
    ### Response
    If deletion is successful, HTTP 204: No Content, otherwise an error message
        
    
    ## Updating
    You can't update using this endpoint
    
    """
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,
                          IsVideoOwnerOrClipOwnerOrReadOnly,)
    queryset = Clip.objects.all().select_related('owner', 'video')
    serializer_class = ClipSerializer
    
    # self.get_object() expects both clip_lookup_field and video_lookup_field
    # lookup clip by case-sensitive 'label'
    clip_lookup_field = 'pk'
    clip_lookup_url_kwarg = 'pk'

    # lookup video by 'hash_key'
    video_lookup_field = 'video__hash_key'
    video_lookup_url_kwarg = 'hash_key'
    
    def get_object(self):
        queryset = self.get_queryset()

        # Perform the lookup filtering.
        clip_lookup = self.kwargs[self.clip_lookup_url_kwarg]
        video_lookup = self.kwargs[self.video_lookup_url_kwarg]
        filter_kwargs = {self.clip_lookup_field: clip_lookup,
                         self.video_lookup_field: video_lookup}
        obj = generics.get_object_or_404(queryset, **filter_kwargs)

        # May raise a permission denied
        self.check_object_permissions(self.request, obj)

        return obj
    
    def delete(self, request, *args, **kwargs):
        """
        Customize the delete operation to not allow deletion of a clip when
        it's the only clip of the video. A video without a clip is weird.
        """
        clip = self.get_object()
        clips_count = clip.video.clips.all().count()
        if clips_count <= 1:
            return Response(
                {'detail': "You can't delete this video's only clip."}, 
                status=status.HTTP_403_FORBIDDEN)
        
        else:
            self.perform_destroy(clip)
            return Response(status=status.HTTP_204_NO_CONTENT)


# -----------------------------------------------------------------------------
# VIDEO USER MANAGEMENT
# -----------------------------------------------------------------------------

class VideoUserList(generics.ListCreateAPIView):
    """
    List all users of a video and add/invite new users.
    
    ## Reading
    ### Permissions
    * Only authenticated users can read this endpoint.
    * Only associated users can read this endpoint for a given video. 
            
    ### Fields
    Reading this endpoint returns a list of VideoUser objects
        
    Name              | Description                             | Type
    ----------------- | --------------------------------------- | ---------- 
    `user`            | user who is associated with this video  | _User object_
    `status`          | invitation status of user in this video | _integer_
                      | * **0**: Invited                        |
                      | * **1**: Viewed post-invite             |
                      | * **2**: Uploaded a clip                |
    `created_at`      | creation date of  VideoUser object      | _date/time_
    `updated_at`      | last update date of  VideoUser object   | _date/time_
    
    
    ### Why return VideoUser objects as opposed to plain User objects?
    * Makes the API more flexible to future changes.
    * If we add properties to each video user, the VideoUser serializer can be
      expanded with these properties and the API would be backwards-compatible.
      
      
    ## Publishing
    ### Permissions
    * Only authenticated users can create using this endpoint.
    * Only associated users can write to this endpoint for a given video.
    
    ### Fields
    Parameter       | Description                | Type
    --------------- | -------------------------- | -----------------------------
    `users`         | a list of video's users    | _list of User number objects_
        
    ####
    Each **`User number object`** has following parameters
    
    Parameter        | Description                        | Type
    ---------------- | ---------------------------------- | ---------- 
    `phone_number`   | User phone number                  | _string_
    
    ### Response
    If create is successful, an object with a `users` field which is a list of
    the UserNumber objects that were just associated with video.
    
    
    ## Deleting
    You can't delete using this endpoint.
    
    
    ## Updating
    You can't update using this endpoint
    
    
    ## Endpoints
    Name                 | Description                       
    -------------------- | ------------------------------------------------
    [`<phone_number>/`](+18006927753/)    | Check/add/remove user's association with a video
    
    ##
    """
    permission_classes = (permissions.IsAuthenticated,
                          IsAssociatedUser)
        
    # IsAssociatedUser and get_queryset() expect lookup fields
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'
    
    def get_queryset(self):
        """
        This view should return a list of all associated users of a video as 
        determined by the lookup parameters of the view.
        """
        
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        lookup = self.kwargs.get(lookup_url_kwarg, None)
                        
        if lookup is not None:
            return VideoUsers.objects.filter(
                video__hash_key=lookup
                ).select_related('user', 'video').order_by('created_at')
        return VideoUsers.objects.none()
    
    def get_serializer_class(self):
        """
        a POST request implies video user creation so return the serializer
        for video user creation. 
        All other requests will be GET so use the VideoUser serializer.
        """
        if self.request.method == "POST":
            return VideoUsersCreationSerializer
        else: 
            return VideoUserSerializer


class VideoUserDetail(generics.GenericAPIView):
    """
    Get/check if a user is associated with a video, add/update/remove a user's 
    association.
    
    ## Reading
    ### Permissions
    * Only authenticated users can read this endpoint.
    * Only associated users can read this endpoint for a given video. 
    
    ### Fields
    If user is associated with the video, a [VideoUser](../) object else an
    empty object if association doesn't exist but user and video do.
    Will get an error message if video/user don't exist, or not authorized to 
    perform this action.
    
    
    ## Publishing
    ### Permissions
    * Only authenticated users can modify a video's associated user.
    * Only associated users or video owner can modify a video's associated
      users. Video owner can modify all users, but an associated user
      can only modify their own user.
    
    ### Fields
    None
        
    ### Response
    If successful, the new/updated VideoUser object, else an error message.
    
    
    ## Deleting
    ### Permissions
    * Only authenticated users can delete a user's association with a video
    * Only associated users or video owner can modify a video's associated
      users. Video owner can modify all users, but an associated user
      can only modify their own user.
    * Current video owner's association to the video cannot be deleted
    
    ### Response
    If successful, a 204 status code, else an error message.
    
    
    ## Updating
    You can't update using this endpoint
    
    """
    permission_classes = (permissions.IsAuthenticated, 
                          IsAssociatedUser, IsOwnerOrUserDetailOwner)
    serializer_class = VideoUserSerializer    
    
    # IsOwnerOrUserDetailOwnerOrAssociatedUserReadOnly expects lookup fields
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'
    
    def get(self, request, hash_key, phone_number, format=None):
        video = get_object_or_404(Video, hash_key=hash_key)
        user = get_object_or_404(User, phone_number=phone_number)
        
        try:
            association = VideoUsers.objects.select_related(
                'user', 'video').get(user=user, video=video)
            serializer = self.get_serializer(association)
            return Response(serializer.data)
        except VideoUsers.DoesNotExist:
            return Response({})
    
    def delete(self, request,  hash_key, phone_number, format=None):
        video = get_object_or_404(Video, hash_key=hash_key)
        user = get_object_or_404(User, phone_number=phone_number)
        
        # if this is the current owner then can't delete the association
        if user.id == video.owner_id:
            raise exceptions.PermissionDenied(
                "Cannot remove video owner's association with video")
        
        association = get_object_or_404(VideoUsers, user=user, video=video)
        association.delete() 
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    def post(self, request,  hash_key, phone_number, format=None):
        return self.update(request, hash_key, phone_number, True, format)
    
    def update(self, request,  hash_key, phone_number, partial, format=None):
        """
        Create/Update VideoUsers association instance
        """
        video = get_object_or_404(Video, hash_key=hash_key)
                
        try:
            user = User.objects.get_user_by_number(phone_number)
        except ValidationError as err:
            raise exceptions.ValidationError({'phone_number': err.messages})
                
        try:
            association = VideoUsers.objects.select_related(
                'user', 'video').get(user=user, video=video)
        except VideoUsers.DoesNotExist:
            association = None
                
        serializer = self.get_serializer(association, data=request.data,
                                         partial=partial)
        serializer.is_valid(raise_exception=True)
                
        if association is None:
            # Create association object here with any properties in
            # serializer, such as
            # permission = serializer.data.get('permission')
            association = VideoUsers.objects.create(user=user, video=video)
            serializer = self.get_serializer(association)
            # log creation 
            activity_send(request.user, verb='invite', 
                          object=user, target=video)
            return Response(serializer.data, status=status.HTTP_201_CREATED)

        association = serializer.save(force_update=True)
        return Response(serializer.data, status=status.HTTP_200_OK)


# -----------------------------------------------------------------------------
# VIDEO LIKE MANAGEMENT
# -----------------------------------------------------------------------------

class VideoLikeList(generics.ListCreateAPIView):
    """
    List all users who have liked a video
    
    ## Reading
    ### Permissions
    * Only authenticated users can read this endpoint.
    * Only associated users can read this endpoint for a given video. 
            
    ### Fields
    Reading this endpoint returns a list of User objects
          
      
    ## Publishing
    You can't write using this endpoint.
    
    
    ## Deleting
    You can't delete using this endpoint.
    
    
    ## Updating
    You can't update using this endpoint
    """
    permission_classes = (permissions.IsAuthenticated,
                          IsAssociatedUser)
    serializer_class = UserPublicSerializer
    
    # IsAssociatedUser and get_queryset() expect lookup fields
    # lookup by 'hash_key' not the 'pk' 
    lookup_field = 'hash_key'
    lookup_url_kwarg = 'hash_key'
    
    def get_queryset(self):
        """
        This view should return a list of all likers of the video referenced
        by the lookup parameters of the view.
        """
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}
        video = generics.get_object_or_404(Video, **filter_kwargs)
        video_content_type = ContentType.objects.get_for_model(video)
        
        return User.objects.filter(
            activities__verb='like', activities__object_id=video.id,
            activities__object_content_type=video_content_type)
    

# -----------------------------------------------------------------------------
# VIDEO WEB MANAGEMENT
# -----------------------------------------------------------------------------

def videodetail(request, hash_key):
    """
    Playback a given video
    
    Args:
        request: HttpRequest object
        
    Returns:
        HttpResponse object
    """
    # get video
    video_queryset = Video.objects.all().select_related('owner')
    video = get_object_or_404(video_queryset, hash_key=hash_key)
    
    clips = video.clips.all()
    
    # Are we reviewing the latest clip?
    start_on_last_clip = request.GET.get('latest', '')
    initialClipIndex = (len(clips) - 1) if start_on_last_clip else 0
    
    return render_to_response('video/details.html',
                              {'video':video,
                               'clips':clips,
                               'initialClipIndex': initialClipIndex},
                              context_instance=RequestContext(request))


@csrf_exempt
def videoclipupload(request, hash_key):
    """
    We need access to temporary_file_path of uploaded clip files so 
    this view always reads files to disk during uploads
    
    However there's a catch, as you can only modify upload handlers before
    accessing request.POST or request.FILES, but CsrfMiddleware accesses
    request.POST. This means we need to use csrf_exempt() on the view to allow
    changing the upload handlers. We then need to use csrf_protect() on the
    function that actually processes the request.
    
    Note that this means that the handlers may start receving the file upload
    before the CSRF checks have been done.
    """
    # need access to temporary_file_path of uploaded clip files so 
    # this view always reads files to disk during uploads
    request.upload_handlers = [TemporaryFileUploadHandler()]
    return _videoclipupload(request, hash_key)
    
@csrf_protect
def _videoclipupload(request, hash_key):
    """
    Upload a clip to a given video
    
    Args:
        request: HttpRequest object
        
    Returns:
        HttpResponse object
    """
    # get video
    video_queryset = Video.objects.all().select_related('owner')
    video = get_object_or_404(video_queryset, hash_key=hash_key)
    
    if request.method == 'POST':
        
        # create a form instance and populate it with data from the request
        form = UploadClipForm(request.POST, request.FILES)
        
        # check whether it's valid
        if form.is_valid():
            # process the data in form.cleaned_data as required
            number = form.cleaned_data['formatted_number'].as_e164
            name = form.cleaned_data['name']
            clip = form.cleaned_data['clip']
                
            # get location of script
            script_dir = os.path.dirname(os.path.abspath(__file__))
            script_path = os.path.join(script_dir, "process.sh")
            
            # get locations of input and output files
            input_video = clip.temporary_file_path()
            output_video = NamedTemporaryFile(suffix='.mp4')
            output_image = NamedTemporaryFile(suffix='.jpg')
            output_duration = NamedTemporaryFile()
            
            # get the ffmpeg path
            # on production we had to install the 64 bit static ffmpeg build
            ffmpeg_path = ''
            if not settings.DEBUG:
                ffmpeg_path = '/home/nceruchalu/bin/'
            
            # Generate the output files
            subprocess.check_call(
                [script_path, input_video, output_video.name, 
                 output_image.name, output_duration.name, ffmpeg_path])
            
            # Get clip duration from the results
            clip_duration = map(float, output_duration)[0]
                        
            # if we've come this far then all is well, and we can go ahead
            # and create this clip
            user = User.objects.get_user_by_number(number)
            if not user.is_active and name:
                user.full_name = name
                user.save()
                
            # first add user as a video user, because nobody should
            # add to a clip without being a video user
            VideoUsers.objects.add_users_to_video(video, user)
            
            # Try creating the clip with a thumbnail, if that fails try
            # without the thumbnail
            Clip.objects.create(owner=user,
                                video=video,
                                mp4=File(output_video),
                                photo=ImageFile(output_image),
                                duration=clip_duration)
            
            # close and delete the tempoary files
            output_video.close()
            output_image.close()
            output_duration.close()
            
            # redirect to the video details URL but add a querystring param
            # indicating that the video should start from the last clip
            video_url = reverse('web-video-detail',kwargs={'hash_key':hash_key})
            redirect_url = "{video_url}?latest=1".format(video_url=video_url)
            
            return HttpResponseRedirect(redirect_url)
        
    else:
        # if a GET (or any other method) we'll create a blank form
        form = UploadClipForm()
        
    return render_to_response('video/upload.html',
                              {'video':video,
                               'form':form},
                              context_instance=RequestContext(request))
